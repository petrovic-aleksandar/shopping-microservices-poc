api-gateway 
8080
koristi spring boot, spring cloud gateway, reactive stack-spring webflux
servlet api vs reactive streams api
tomcat vs Netty(event loop as a core, continiously listens for I/O events, registers callbacks
    when events occur, channel http req/resp, tcp socket, non blocking events queued to event loop
    handler-code that processes eventss, pipeline-chain of handlers). netty is an async network
    application framework built on java NIO
thread per request vs event loop model(small thread pool)
returns objects vs returns Mono<T> or Flux<T>
blocking io vs non blocking i/o

reasons tu use a gateway: single entry point, auth, routing logic, cross cutting concerns(logging,
    rate limiting, monitoring and metrics, error handling), load balancing, service discovery

auth-service
8081
tradicionalna tomcat bloking aplikacija, zove je non-blocking async api-gateway

order-service
8082
tradicionalna tomcat synch app, ali takodje i publishuje i subscribuje na kafka topics.
kreira novi order sa statusom CREATED, publishuje order.created event, vraca order odmah(non-block)
getuje order
slusa payment rezultate - kafka consumer na topics payment.succeded, payment.failed
saga pattern: kompenzacija se desi ako je failed event

inventory-service
8084
tradicionalna tomcat sinhrona app, ali takodje pub/sub na kafka topike
vraca stanje u magacinu
rezervise producte manuelno
slusa kafku order.created topic, i pokusa da rezervise, publishuje reservation.succeeded ili failed
thread-safe kad pokusa da rezervise
ovo je saga pattern sa kompenzacijom, ako je failed, payment se ne desi
slusa kafku i na payment.failed, i vrati rezervaciju(kompenzacija u saga patternu)

payment-service
8083
tradicionalna tomcat sinhrona app, ali takodje i pub/subscribuje na kafka topics
sub na reservation.succeded, vrsi placanje onda publish na payment.succeded ili failed

kafka + zookeeper + kafka ui
kafka: 9092 (broker port)
zookeeper: 2181 (koordinacija za kafku)
kafka-ui: 8085 (web interface za management i monitoring)
distributed event streaming platform, pub/sub messaging, event sourcing
koristi se za komunikaciju izmedju mikroservisa (order -> inventory -> payment)
topics: order.created, reservation.succeeded, reservation.failed, payment.succeeded, payment.failed

centralized logging:
elk stack (elasticsearch + kibana + filebeat)
elasticsearch: 9200 (REST API), 9300 (node communication)
kibana: 5601 (web UI za pretragu i vizualizaciju logova)
filebeat: log shipper, prikuplja logove iz /logs direktorijuma i salje ih u elasticsearch
centralized logging - svi logovi iz svih mikroservisa na jednom mestu
structured logging - JSON format sa logstash encoder
indeksi po servisu: order-service-*, inventory-service-*, payment-service-*
mogu se pretrazivati logovi po servisu, nivou (ERROR, INFO), timestamp-u
multiline pattern za Java stack trace-ove



