api-gateway 
8080
koristi spring boot, spring cloud gateway, reactive stack-spring webflux
servlet api vs reactive streams api
tomcat vs Netty(event loop as a core, continiously listens for I/O events, registers callbacks
    when events occur, channel http req/resp, tcp socket, non blocking events queued to event loop
    handler-code that processes eventss, pipeline-chain of handlers). netty is an async network
    application framework built on java NIO
thread per request vs event loop model(small thread pool)
returns objects vs returns Mono<T> or Flux<T>
blocking io vs non blocking i/o

reasons tu use a gateway: single entry point, auth, routing logic, cross cutting concerns(logging,
    rate limiting, monitoring and metrics, error handling), load balancing, service discovery

auth-service
8081
tradicionalna tomcat bloking aplikacija, zove je non-blocking async api-gateway

order-service
8082
tradicionalna tomcat synch app, ali takodje i publishuje i subscribuje na kafka topics.
kreira novi order sa statusom CREATED, publishuje order.created event, vraca order odmah(non-block)
getuje order
slusa payment rezultate - kafka consumer na topics payment.succeded, payment.failed
saga pattern: kompenzacija se desi ako je failed event

inventory-service
8084
tradicionalna tomcat sinhrona app, ali takodje pub/sub na kafka topike
vraca stanje u magacinu
rezervise producte manuelno
slusa kafku order.created topic, i pokusa da rezervise, publishuje reservation.succeeded ili failed
thread-safe kad pokusa da rezervise
ovo je saga pattern sa kompenzacijom, ako je failed, payment se ne desi
slusa kafku i na payment.failed, i vrati rezervaciju(kompenzacija u saga patternu)

payment-service
8083
tradicionalna tomcat sinhrona app, ali takodje i pub/subscribuje na kafka topics


kafka
8085



